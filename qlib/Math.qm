# -*- mode: qore; indent-tabs-mode: nil -*-
# @file Math.qm Mathematical functions

/*  Math.qm Copyright 2016 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.8.12

%new-style
%require-types
%enable-all-warnings

module Math {
    version = "0.1";
    desc    = "Mathematical functions";
    author  = "Martin Otto <martin@qore.org>";
    url     = "https://qore.org";
    license = "MIT";
    init    = sub () { init(); };
}

namespace Init {
    sub init() {
    }
}

public namespace Math {
    # Some useful constants
    public const M_E = 2.718281828459045235360287471352662497757247093699959574966;
    public const M_PI = 3.141592653589793238462643383279502884197169399375105820974;
    public const M_SQRTPI = 1.772453850905516027298167483341145182797549456122387128213;
    public const M_LOGPI = 1.144729885849400174143427351353058711647294812915311571513;

    #! Return x factorial.
    /**
        @throw "VALUE-ERROR" if x is not integral or is negative
    */
    public number sub factorial (softnumber x) {
        if (x < 0)
            throw "VALUE-ERROR", "factorial() only accepts integral values";
        if (x != floor(x))
            throw "VALUE-ERROR", "factorial() not defined for negative values";
        number r = 1;
        if (x >= 2)
            for (number i=2; i<=x; ++i)
                r *= i;
        return r;
    }

    #! Return the Gamma function at x. Lanczos approximation.
    public float sub gamma (softfloat x) {
        list p = (
                0.99999999999980993, 676.5203681218851, -1259.1392167224028,
                771.32342877765313, -176.61502916214059, 12.507343278686905,
                -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
                );
        int g = 7;

        if (x < 0.5)
            return M_PI / (sin (M_PI * x) * gamma (1-x));

        x -= 1;
        float a = p[0];
        float t = x + g + 0.5;
        for (int i=1; i < p.size(); ++i)
            a += p[i] / (x+i);

        return sqrt(2*M_PI) * pow(t, x+0.5) * exp(-t) * a;
    }

    #! Return the logarithm of x to the given base, calculated as nlog(x)/nlog(base).
    public float sub log (softfloat f, softfloat base = M_E) {
        return nlog(f) / nlog(base);
    }

    #! Return the logarithm of x to the given base, calculated as nlog(x)/nlog(base).
    public number sub log (number n, number base = M_E) {
        return nlog(n) / nlog(base);
    }

    #! Return arithmetic mean ("average") of numeric data.
    /**
        The arithmetic mean is the sum of the data divided by the number of data points.
        It is commonly called “the average”, although it is only one of many different mathematical averages.
        It is a measure of the central location of the data.

        @throw "VALUE-ERROR" if the list is empty
    */
    public any sub mean (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "mean() requires at least one data point";
        return psum(la) / float(n);
    }

    #! Return median (middle value) of numeric data, using the common "mean of middle two" method.
    /**
        The median is a robust measure of central location, and is less affected by the presence of outliers in your data.
        When the number of data points is odd, the middle data point is returned.
        When the number of data points is even, the median is interpolated by taking the average of the two middle values.

        @throw "VALUE-ERROR" if the list is empty

        @see @ref Math::median_low(), @ref Math::median_high()
    */
    public any sub median (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "median() requires at least one data point";
        list s = sort(la);
        if (n % 2 == 1)
            return s[n/2];
        int i = n/2;
        return (s[i-1] + s[i]) / 2.0;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        This generic version selects datatype based on either start argument (if used)
        or based on first item of the list.  Use specific versions to force datatype,
        especially when high precision summation of float / number values is required.

        @see @ref Math::isum(), @ref Math::fsum(), @ref Math::nsum(), @ref Math::psum()
    */
    public any sub sum (list la, *any start) {
        map start += $1, la;
        return start ?? 0;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    public int sub isum (list li, int start = 0) {
        map start += $1, li;
        return start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        Full precision summation using multiple floats for intermediate values.
    */
    public float sub fsum (list lf, float start = 0.0) {
        # Rounded x+y stored in hi with the round-off stored in lo.  Together
        # hi+lo are exactly equal to x+y.  The inner loop applies hi/lo summation
        # to each partial so that the list of partial sums remains exact.
        # Depends on IEEE-754 arithmetic guarantees.  See proof of correctness at:
        # www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps

        list partials = (); # sorted, non-overlapping partial sums
        foreach float x in (lf) {
            int i = 0;
            foreach float y in (partials) {
                if (abs(x) < abs(y)) {
                    float a = x; x = y; y = a;
                }
                float hi = x + y;
                float lo = y - (hi - x);
                if (lo) {
                    partials[i] = lo;
                    i += 1;
                }
                x = hi;
            }
            splice partials, i, MAXINT, x;
        }
        float r;
        map r += $1, partials;
        return r + start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    public number sub nsum (list ln, number start = 0n) {
        map start += $1, ln;
        return start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        Full precision summation version of the generic sum() function.

        This generic version selects datatype based on either start argument (if used)
        or based on the first item of the list.

        @see @ref Math::sum(), @ref Math::isum(), @ref Math::fsum(), @ref Math::nsum()
    */
    public any sub psum (list la, *any start) {
        any x = start ?? la[0];
        switch (x.typeCode()) {
            case NT_NUMBER:
                return nsum (la, start ?? 0);
            case NT_FLOAT:
                return fsum (la, start ?? 0);
            case NT_INT:
                return isum (la, start ?? 0);
            default:
                if (start === NOTHING && la.size() == 0)
                    return 0;
                throw "VALUE-ERROR", "sum() only accepts numeric values";
        }
    }
}

# vim:et:sw=4:ts=4:sts=4:
