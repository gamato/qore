# -*- mode: qore; indent-tabs-mode: nil -*-
# @file Math.qm Mathematical functions

/*  Math.qm Copyright 2016 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.8.12

%new-style
%require-types
%enable-all-warnings

module Math {
    version = "0.1";
    desc    = "Mathematical functions";
    author  = "Martin Otto <martin@qore.org>";
    url     = "https://qore.org";
    license = "MIT";
    init    = sub () { init(); };
}

namespace Init {
    sub init() {
    }
}

public namespace Math {
    # Some useful constants
    public const M_E = 2.718281828459045235360287471352662497757247093699959574966;
    public const M_PI = 3.141592653589793238462643383279502884197169399375105820974;
    public const M_SQRTPI = 1.772453850905516027298167483341145182797549456122387128213;
    public const M_LOGPI = 1.144729885849400174143427351353058711647294812915311571513;

    #! Return x factorial.
    /**
        @throw "VALUE-ERROR" if x is not integral or is negative
    */
    public number sub factorial (softnumber x) {
        if (x < 0)
            throw "VALUE-ERROR", "factorial() only accepts integral values";
        if (x != floor(x))
            throw "VALUE-ERROR", "factorial() not defined for negative values";
        number r = 1;
        if (x >= 2)
            for (number i=2; i<=x; ++i)
                r *= i;
        return r;
    }

    #! Return the Gamma function at x. Lanczos approximation.
    public float sub gamma (softfloat x) {
        list p = (
                0.99999999999980993, 676.5203681218851, -1259.1392167224028,
                771.32342877765313, -176.61502916214059, 12.507343278686905,
                -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
                );
        int g = 7;

        if (x < 0.5)
            return M_PI / (sin (M_PI * x) * gamma (1-x));

        x -= 1;
        float a = p[0];
        float t = x + g + 0.5;
        for (int i=1; i < p.size(); ++i)
            a += p[i] / (x+i);

        return sqrt(2*M_PI) * pow(t, x+0.5) * exp(-t) * a;
    }

    #! Return the logarithm of x to the given base, calculated as nlog(x)/nlog(base).
    public float sub log (softfloat f, softfloat base = M_E) {
        return nlog(f) / nlog(base);
    }

    #! Return the logarithm of x to the given base, calculated as nlog(x)/nlog(base).
    public number sub log (number n, number base = M_E) {
        return nlog(n) / nlog(base);
    }

    #! Return arithmetic mean ("average") of numeric data.
    /**
        The arithmetic mean is the sum of the data divided by the number of data points.
        It is commonly called “the average”, although it is only one of many different mathematical averages.
        It is a measure of the central location of the data.

        @throw "VALUE-ERROR" if the list is empty
    */
    public any sub mean (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "mean() requires at least one data point";
        return psum(la) / float(n);
    }

    #! Return median (middle value) of numeric data, using the common "mean of middle two" method.
    /**
        The median is a robust measure of central location, and is less affected by the presence of outliers in your data.
        When the number of data points is odd, the middle data point is returned.
        When the number of data points is even, the median is interpolated by taking the average of the two middle values.

        @throw "VALUE-ERROR" if the list is empty

        @see @ref Math::median_low(), @ref Math::median_high()
    */
    public any sub median (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "median() requires at least one data point";
        list s = sort(la);
        if (n % 2 == 1)
            return s[n/2];
        int i = n/2;
        return (s[i-1] + s[i]) / 2.0;
    }

    #! Return the low median of numeric data.
    /**
        When the number of data points is odd, the middle value is returned.
        When it is even, the smaller of the two middle values is returned.

        @throw "VALUE-ERROR" if the list is empty

        @see @ref Math::median_high(), @ref Math::median()
    */
    public any sub median_low (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "median() requires at least one data point";
        list s = sort(la);
        if (n % 2 == 1)
            return s[n/2];
        return s[n/2 - 1];
    }

    #! Return the high median of numeric data.
    /**
        When the number of data points is odd, the middle value is returned.
        When it is even, the larger of the two middle values is returned.

        @throw "VALUE-ERROR" if the list is empty

        @see @ref Math::median_low(), @ref Math::median()
    */
    public any sub median_high (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "median() requires at least one data point";
        list s = sort(la);
        return s[n/2];
    }

    #! Return the most common data point(s) from discrete or nominal data.
    /**
        @throw "VALUE-ERROR" if the list is empty
    */
    public list sub mode (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "mode() requires at least one data point";
        Multiset ms (la);
        list h = ms.most_common();
        int m = h[0][1];
        list r = map $1[0], h, $1[1] == m;
        return r;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        This generic version selects datatype based on either start argument (if used)
        or based on first item of the list.  Use specific versions to force datatype,
        especially when high precision summation of float / number values is required.

        @see @ref Math::isum(), @ref Math::fsum(), @ref Math::nsum(), @ref Math::psum()
    */
    public any sub sum (list la, *any start) {
        map start += $1, la;
        return start ?? 0;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    public int sub isum (list li, int start = 0) {
        map start += $1, li;
        return start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        Full precision summation using multiple floats for intermediate values.
    */
    public float sub fsum (list lf, float start = 0.0) {
        # Rounded x+y stored in hi with the round-off stored in lo.  Together
        # hi+lo are exactly equal to x+y.  The inner loop applies hi/lo summation
        # to each partial so that the list of partial sums remains exact.
        # Depends on IEEE-754 arithmetic guarantees.  See proof of correctness at:
        # www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps

        list partials = (); # sorted, non-overlapping partial sums
        foreach float x in (lf) {
            int i = 0;
            foreach float y in (partials) {
                if (abs(x) < abs(y)) {
                    float a = x; x = y; y = a;
                }
                float hi = x + y;
                float lo = y - (hi - x);
                if (lo) {
                    partials[i] = lo;
                    i += 1;
                }
                x = hi;
            }
            splice partials, i, MAXINT, x;
        }
        float r;
        map r += $1, partials;
        return r + start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    public number sub nsum (list ln, number start = 0n) {
        map start += $1, ln;
        return start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        Full precision summation version of the generic sum() function.

        This generic version selects datatype based on either start argument (if used)
        or based on the first item of the list.

        @see @ref Math::sum(), @ref Math::isum(), @ref Math::fsum(), @ref Math::nsum()
    */
    public any sub psum (list la, *any start) {
        any x = start ?? la[0];
        switch (x.typeCode()) {
            case NT_NUMBER:
                return nsum (la, start ?? 0);
            case NT_FLOAT:
                return fsum (la, start ?? 0);
            case NT_INT:
                return isum (la, start ?? 0);
            default:
                if (start === NOTHING && la.size() == 0)
                    return 0;
                throw "VALUE-ERROR", "sum() only accepts numeric values";
        }
    }
}

# ============================== helper code ==============================

#! Return a new list as 'num' times concatenated 'arg' list.
list sub Math::listmul (softlist arg, softint num) {
    list r = ();
    while (num > 0) {
        r += arg;
        --num;
    }
    return r;
}


#! Class for constructing and manipulating unordered collections of unique elements.
/**
    Common uses include membership testing, removing duplicates from a list,
    and computing standard math operations on sets such as intersection,
    union, difference, and symmetric difference.
*/
public class Math::AbstractSet {
    private {
    }

    constructor (any x) {
        if (exists x)
            self.merge(x);
    }

    # ========== Modifiers ==============================

    # ---------- single element operations ----------

    #! Insert an element into the set. Do nothing if it is already there.
    abstract add (any x);

    #! Remove an element from the set. Do nothing if it is not there.
    abstract discard (any x);

    # ---------- mathematical set operations ----------

    #! Remove all elements from the set that are not contained in a ListIterator.
    intersect (Qore::ListIterator x) {
        # self.intersect (new AbstractSet (x));
        list i = map $1, x, self.count($1);
        self.clear();
        self.merge(i);
    }

    #! Remove all elements from the set that are not contained in a list.
    intersect (list x) {
        self.intersect (x.iterator());
    }

    #! Remove all elements from this set that are not contained in the other set.
    intersect (AbstractSet other) {
        map self.discard ($1), self.item_iterator(), !other.count($1);
    }

    #! Read elements from a ListIterator and insert each into the set.
    merge (Qore::ListIterator x) {
        map self.add ($1), x;
    }

    #! Read elements from a list and insert each into the set.
    merge (list x) {
        self.merge (x.iterator());
    }

    #! Insert all elements found in the other set into this set.
    merge (AbstractSet other) {
        # self.merge (other.item_iterator());
        self.merge (other.items().iterator());
    }

    #! Read elements from item_iterator() call and insert each into the set.
    merge (Math::AbstractSetItemIterator x) {
        map self.add ($1), x;
    }

    #! Read elements from a ListIterator and remove each from the set.
    subtract (Qore::ListIterator x) {
        map self.discard ($1), x;
    }

    #! Read elements from a list and remove each from the set.
    subtract (list x) {
        self.subtract (x.iterator());
    }

    #! Remove all elements found in the other set from this set.
    subtract (AbstractSet other) {
        # self.subtract (other.item_iterator());
        self.subtract (other.items().iterator());
    }

    #! Update the set to contain only elements exclusive between the set and a ListIterator.
    symmetric_subtract (Qore::ListIterator x) {
        # self.symmetric_subtract (new AbstractSet (x));
        list i = map $1, x, self.count($1);
        self.merge (x);
        self.subtract (i);
    }

    #! Update the set to contain only elements exclusive between the set and a list.
    symmetric_subtract (list x) {
        self.symmetric_subtract (x.iterator());
    }

    #! Update the set to contain only elements exclusive between this set and the other set.
    symmetric_subtract (AbstractSet other) {
        list i;
        if (self.size() < other.size())
            i = map $1, self.item_iterator(), other.count($1);
        else
            i = map $1, other.item_iterator(), self.count($1);
        self.merge (other);
        self.subtract (i);
    }

    # ---------- miscellaneous ----------

    abstract clear ();

    # ========== Queries ==============================

    # ---------- mathematical set operations ----------

    #! Return True if the set is empty (size = 0), False if not.
    bool empty () {
        return ! boolean (self.size());
    }

    #! Return the number of elements in this set (its cardinality).
    int size () {
        int s = 0;
        map s += 1, self.item_iterator();
        return s;
    }

    # ---------- single element operations ----------

    #! Return True if the set contains a specified element, False if not.
    bool contains (any x) {
        return boolean (self.count(x));
    }

    #! Return number of occurrences of an element (which is either 1 or 0).
    abstract int count (any x);

    # ========== Miscellaneous ==============================

    abstract list items ();
    abstract AbstractIterator item_iterator ();
}

class Math::AbstractSetItemIterator inherits AbstractIterator {
}


#! Class for constructing and manipulating unordered collections of unique elements.
/**
    Elements are stored as hash keys and therefore they have to be hashable.

    @note This class is faster than @ref Math::Set but it is not safe to be used with values other than strings.
*/
public class Math::UnsafeSet inherits Math::AbstractSet {
    private {
        hash _h = {};
    }

    constructor (any x) : AbstractSet (x) {
    }

    # ========== Modifiers ==============================

    # ---------- single element operations ----------

    #! Insert an element into the set. Do nothing if it is already there.
    add (any item) {
        _h.(item.toString()) = True;
    }

    #! Remove an element from the set. Do nothing if it is not there.
    discard (any item) {
        delete _h.(item.toString());
    }

    # ---------- miscellaneous ----------

    #! Remove all elements from the set.
    clear () {
        _h = {};
    }

    # ========== Queries ==============================

    # ---------- mathematical set operations ----------

    #! Return the number of elements in this set (its cardinality).
    int size () {
        return _h.size();
    }

    # ---------- single element operations ----------

    #! Return True if the set contains a specified element, False if not.
    bool contains (any x) {
        return exists _h.(x.toString());
    }

    #! Return number of occurrences of an element (which is either 1 or 0).
    int count (any x) {
        return exists _h.(x.toString()) ? 1 : 0;
    }

    # ========== Miscellaneous ==============================

    #! Return internal hash structure. Note: not part of API; implementation specific (!)
    any dump () {
        return _h;
    }

    #! Return all elements.
    /**
        Elements are returned in arbitrary order.
    */
    list items () {
        return _h.keys();
    }

    #! Return an iterator over all elements.
    /**
        Elements are returned in arbitrary order.
    */
    AbstractIterator item_iterator () {
        return new UnsafeSetItemIterator (_h.keyIterator());
    }
}

class Math::UnsafeSetItemIterator inherits Math::AbstractSetItemIterator {
    private {
        HashKeyIterator _iter;
    }

    constructor (HashKeyIterator iter) {
        _iter = iter;
    }

    bool valid() {
        return _iter.valid();
    }

    bool next() {
        return _iter.next();
    }

    any getValue() {
        return _iter.getValue();
    }
}


/**
    Class for counting hashable items.  Sometimes called a counter or bag or multiset.

    @see http://en.wikipedia.org/wiki/Multiset
*/
public class Math::AbstractMultiset {
    private {
    }

    constructor (any x) {
        if (exists x)
            self.merge(x);
    }

    #! Insert an element (once or more) into the multiset.
    abstract add (any item, int count = 1);

    #! Remove an element (once or more) from the multiset.
    abstract discard (any item, int count = 1);

    #! Read elements from a ListIterator and insert each into the multiset.
    merge (Qore::ListIterator x) {
        map self.add ($1), x;
    }

    #! Read (element: count) from a HashPairIterator and insert each into the multiset.
    merge (Qore::HashPairIterator x) {
        map self.add ($1.key, $1.value), x;
    }

    #! Read elements from a list and insert each into the multiset.
    merge (list x) {
        self.merge (x.iterator());
    }

    #! Read (element: count) from a hash and insert each into the multiset.
    merge (hash x) {
        self.merge (x.pairIterator());
    }

    #! Insert all elements found in the other multiset into this multiset.
    merge (AbstractMultiset other) {
        self.merge (other.pair_iterator());
    }

    #! Read elements from item_iterator() call and insert each into the multiset.
    merge (Math::AbstractMultisetItemIterator x) {
        map self.add ($1), x;
    }

    #! Read (element: count) from pair_iterator() call and insert each into the multiset.
    merge (Math::AbstractMultisetPairIterator x) {
        map self.add ($1[0], $1[1]), x;
    }

    #! Read elements from a ListIterator and remove each from the multiset.
    subtract (Qore::ListIterator x) {
        map self.discard ($1), x;
    }

    #! Read (element: count) from a HashPairIterator and remove each from the multiset.
    subtract (Qore::HashPairIterator x) {
        map self.discard ($1.key, $1.value), x;
    }

    #! Read elements from a list and remove each from the multiset.
    subtract (list x) {
        self.subtract (x.iterator());
    }

    #! Read (element: count) from a hash and remove each from the multiset.
    subtract (hash x) {
        self.subtract (x.pairIterator());
    }

    #! Remove all elements found in the other multiset from this multiset.
    subtract (AbstractMultiset other) {
        self.subtract (other.pair_iterator());
    }

    #! Read elements from item_iterator() call and remove each from the multiset.
    subtract (Math::AbstractMultisetItemIterator x) {
        map self.discard ($1), x;
    }

    #! Read (element: count) from pair_iterator() call and remove each from the multiset.
    subtract (Math::AbstractMultisetPairIterator x) {
        map self.discard ($1[0], $1[1]), x;
    }

    abstract clear ();
    abstract int count (any item);
    abstract list items ();
    abstract AbstractIterator item_iterator ();
    abstract list pairs ();
    abstract AbstractIterator pair_iterator ();
    abstract list most_common (*int n);

    #! Return True if the multiset contains a specified element, False if not.
    bool contains (any item) {
        return boolean (self.count(item));
    }

    #! Return True if the multiset is empty (size = 0), False if not.
    bool empty () {
        return ! boolean (self.size());
    }

    #! Return the number of elements in this multiset (its cardinality).
    int size () {
        int s = 0;
        map s += $1[1], self.pair_iterator();
        return s;
    }
}

class Math::AbstractMultisetItemIterator inherits AbstractIterator {
}

class Math::AbstractMultisetPairIterator inherits AbstractIterator {
}


/**
    Class for counting hashable items.  Sometimes called a counter or bag or multiset.
    Elements are indexed as hash keys and their {type, value, count} are stored as hash values.

    @note This class is slower than @ref Math::UnsafeMultiset but it is safe to be used with values other than strings.

    @see http://en.wikipedia.org/wiki/Multiset
*/
public class Math::Multiset inherits Math::AbstractMultiset {
    private {
        hash _h = {}; # consists of hashes with keys 'count', 'value', 'type'
    }

    constructor (any x) : AbstractMultiset (x) {
    }

    #! Insert an element (once or more) into the multiset.
    add (any item, int count = 1) {
        string k = item.toString();
        if (!exists _h.(k)) {
            _h.(k) = { 'count': count, 'value': item, 'type': item.typeCode() };
            continue;
        }
        reference r = \_h.(k);
        if (r.type != item.typeCode() || r.value != item)
            throw "MULTISET-ERROR", sprintf ("cannot safely handle %s %y -- multiset already contains %s %y",
                    item.type(), item, TypeCodeMap.(r.type), r.value);
        r.count += count;
    }

    #! Remove an element (once or more) from the multiset.
    discard (any item, int count = 1) {
        string k = item.toString();
        if (!exists _h.(k)) {
            _h.(k) = { 'count': -count, 'value': item, 'type': item.typeCode() };
            continue;
        }
        reference r = \_h.(k);
        if (r.type != item.typeCode() || r.value != item)
            throw "MULTISET-ERROR", sprintf ("cannot safely handle %s %y -- multiset already contains %s %y",
                    item.type(), item, TypeCodeMap.(r.type), r.value);
        r.count -= count;
    }

    #! Insert all elements found in the other multiset into this multiset.
    merge (Math::Multiset other) {
        map self.add ($1.value, $1.count), other.dump().iterator();
    }

    #! Remove all elements found in the other multiset from this multiset.
    subtract (Math::Multiset other) {
        map self.discard ($1.value, $1.count), other.dump().iterator();
    }

    #! Remove all elements from the multiset.
    clear () {
        _h = {};
    }

    #! Return number of occurrences of an element.
    int count (any item) {
        int c = _h.(item.toString()).count ?? 0;
        return c > 0 ? c : 0;
    }

    #! Return all elements repeating each as many times as its count.
    /**
        If an element’s count is less than one, items() will ignore it.
        Elements are returned in arbitrary order.
    */
    list items () {
        list r = ();
        map r += listmul ($1.value, $1.count), _h.iterator(), $1.count > 0;
        return r;
    }

    #! Return an iterator returning all elements repeating each as many times as its count.
    /**
        If an element’s count is less than one, item_iterator() will ignore it.
        Elements are returned in arbitrary order.
    */
    AbstractIterator item_iterator () {
        return new MultisetItemIterator (_h.iterator());
    }

    #! Return all elements as a list of (value, count) pairs.
    /**
        If an element’s count is less than one, pairs() will ignore it.
        Elements are returned in arbitrary order.
    */
    list pairs () {
        return map ($1.value, $1.count), _h.iterator(), $1.count > 0;
    }

    #! Return an iterator returning all elements as a list of (value, count) pairs.
    /**
        If an element’s count is less than one, pair_iterator() will ignore it.
        Elements are returned in arbitrary order.
    */
    AbstractIterator pair_iterator () {
        return new MultisetPairIterator (_h.iterator());
    }

    #! Return internal hash structure. Note: not part of API; implementation specific (!)
    any dump () {
        return _h;
    }

    #! Return the n most common elements and their counts from the most common to the least.
    /**
        Return the n most common elements and their counts from the most common to the least.
        If n is omitted or NOTHING, then return all element counts.
    */
    list most_common (*int n) {
        list x = map ($1.value, $1.count), _h.iterator();
        code f = int sub (list l, list r) { return l[1] <=> r[1]; };
        list s = sort_descending_stable (x, f);
        if (exists n)
            if (n >= 0)
                splice s, n;
            else if (-n < s.size())
                splice s, 0, s.size() + n;
        return s;
    }

    #! Return the number of elements in this multiset (its cardinality).
    int size () {
        int s = 0;
        map s += $1.count, _h.iterator();
        return s;
    }
}

class Math::MultisetItemIterator inherits Math::AbstractMultisetItemIterator {
    private {
        HashIterator _iter;
        any _value;
        int _count;
    }

    constructor (HashIterator iter) {
        _iter = iter;
    }

    bool valid() {
        return _iter.valid();
    }

    bool next() {
        while (!(_count > 0) && _iter.next()) {
            hash h = _iter.getValue();
            _value = h.value;
            _count = h.count;
        }
        _count -= 1;
        return _iter.valid();
    }

    any getValue() {
        if (_iter.valid())
            return _value;
        _iter.getValue(); # force ITERATOR-ERROR builtin exception
    }
}

class Math::MultisetPairIterator inherits Math::AbstractMultisetPairIterator {
    private {
        HashIterator _iter;
    }

    constructor (HashIterator iter) {
        _iter = iter;
    }

    bool valid() {
        return _iter.valid();
    }

    bool next() {
        while (_iter.next() && !(_iter.getValue().count > 0)) {
        }
        return _iter.valid();
    }

    any getValue() {
        hash h = _iter.getValue();
        return (h.value, h.count);
    }
}


/**
    Class for counting hashable items.  Sometimes called a counter or bag or multiset.
    Elements are stored as hash keys and their counts are stored as hash values.

    @note This class is faster than @ref Math::Multiset but it is not safe to be used with values other than strings.

    @see http://en.wikipedia.org/wiki/Multiset
*/
public class Math::UnsafeMultiset inherits Math::AbstractMultiset {
    private {
        hash _h = {};
    }

    constructor (any x) : AbstractMultiset (x) {
    }

    #! Insert an element (once or more) into the multiset.
    add (any item, int count = 1) {
        _h.(item.toString()) += count;
    }

    #! Remove an element (once or more) from the multiset.
    discard (any item, int count = 1) {
        _h.(item.toString()) -= count;
    }

    #! Read elements from a ListIterator and insert each into the multiset.
    merge (Qore::ListIterator x) {
        map _h.($1.toString()) += 1, x;
    }

    #! Read (element: count) from a HashPairIterator and insert each into the multiset.
    merge (Qore::HashPairIterator x) {
        map _h.($1.key) += $1.value, x;
    }

    #! Read elements from item_iterator() call and insert each into the multiset.
    merge (Math::AbstractMultisetItemIterator x) {
        map _h.($1.toString()) += 1, x;
    }

    #! Read (element: count) from pair_iterator() call and insert each into the multiset.
    merge (Math::AbstractMultisetPairIterator x) {
        map _h.($1[0].toString()) += $1[1], x;
    }

    #! Insert all elements found in the other multiset into this multiset.
    merge (Math::UnsafeMultiset other) {
        map _h.($1.key) += $1.value, other.dump().pairIterator();
    }

    #! Read elements from a ListIterator and remove each from the multiset.
    subtract (Qore::ListIterator x) {
        map _h.($1.toString()) -= 1, x;
    }

    #! Read (element: count) from a HashPairIterator and remove each from the multiset.
    subtract (Qore::HashPairIterator x) {
        map _h.($1.key) -= $1.value, x;
    }

    #! Read elements from item_iterator() call and remove each from the multiset.
    subtract (Math::AbstractMultisetItemIterator x) {
        map _h.($1.toString()) -= 1, x;
    }

    #! Read (element: count) from pair_iterator() call and remove each from the multiset.
    subtract (Math::AbstractMultisetPairIterator x) {
        map _h.($1[0].toString()) -= $1[1], x;
    }

    #! Remove all elements found in the other multiset from this multiset.
    subtract (Math::UnsafeMultiset other) {
        map _h.($1.key) -= $1.value, other.dump().pairIterator();
    }

    #! Remove all elements from the multiset.
    clear () {
        _h = {};
    }

    #! Return number of occurrences of an element.
    int count (any item) {
        int c = _h.(item.toString()) ?? 0;
        return c > 0 ? c : 0;
    }

    #! Return all elements repeating each as many times as its count.
    /**
        If an element’s count is less than one, items() will ignore it.
        Elements are returned in arbitrary order.
    */
    list items () {
        list r = ();
        map r += listmul ($1.key, $1.value), _h.pairIterator(), $1.value > 0;
        return r;
    }

    #! Return an iterator returning all elements repeating each as many times as its count.
    /**
        If an element’s count is less than one, item_iterator() will ignore it.
        Elements are returned in arbitrary order.
    */
    AbstractIterator item_iterator () {
        return new UnsafeMultisetItemIterator (_h.pairIterator());
    }

    #! Return all elements as a list of (value, count) pairs.
    /**
        If an element’s count is less than one, pairs() will ignore it.
        Elements are returned in arbitrary order.
    */
    list pairs () {
        return map ($1.key, $1.value), _h.pairIterator(), $1.value > 0;
    }

    #! Return an iterator returning all elements as a list of (value, count) pairs.
    /**
        If an element’s count is less than one, pair_iterator() will ignore it.
        Elements are returned in arbitrary order.
    */
    AbstractIterator pair_iterator () {
        return new UnsafeMultisetPairIterator (_h.pairIterator());
    }

    #! Return internal hash structure. Note: not part of API; implementation specific (!)
    any dump () {
        return _h;
    }

    #! Return the n most common elements and their counts from the most common to the least.
    /**
        Return the n most common elements and their counts from the most common to the least.
        If n is omitted or NOTHING, then return all element counts.
    */
    list most_common (*int n) {
        list x = map ($1.key, $1.value), _h.pairIterator();
        code f = int sub (list l, list r) { return l[1] <=> r[1]; };
        list s = sort_descending_stable (x, f);
        if (exists n)
            if (n >= 0)
                splice s, n;
            else if (-n < s.size())
                splice s, 0, s.size() + n;
        return s;
    }

    #! Return the number of elements in this multiset (its cardinality).
    int size () {
        int s = 0;
        map s += $1, _h.iterator();
        return s;
    }
}

class Math::UnsafeMultisetItemIterator inherits Math::AbstractMultisetItemIterator {
    private {
        HashPairIterator _iter;
        any _value;
        int _count;
    }

    constructor (HashPairIterator iter) {
        _iter = iter;
    }

    bool valid() {
        return _iter.valid();
    }

    bool next() {
        while (!(_count > 0) && _iter.next()) {
            hash h = _iter.getValue();
            _value = h.key;
            _count = h.value;
        }
        _count -= 1;
        return _iter.valid();
    }

    any getValue() {
        if (_iter.valid())
            return _value;
        _iter.getValue(); # force ITERATOR-ERROR builtin exception
    }
}

class Math::UnsafeMultisetPairIterator inherits Math::AbstractMultisetPairIterator {
    private {
        HashPairIterator _iter;
    }

    constructor (HashPairIterator iter) {
        _iter = iter;
    }

    bool valid() {
        return _iter.valid();
    }

    bool next() {
        while (_iter.next() && !(_iter.getValue().value > 0)) {
        }
        return _iter.valid();
    }

    any getValue() {
        hash h = _iter.getValue();
        return (h.key, h.value);
    }
}

# vim:et:sw=4:ts=4:sts=4:
