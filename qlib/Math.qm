# -*- mode: qore; indent-tabs-mode: nil -*-
# @file Math.qm Mathematical functions

/*  Math.qm Copyright 2016 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.8.12

%new-style
%require-types
%enable-all-warnings

module Math {
    version = "0.1";
    desc    = "Mathematical functions";
    author  = "Martin Otto <martin@qore.org>";
    url     = "https://qore.org";
    license = "MIT";
    init    = sub () { init(); };
}

namespace Init {
    sub init() {
    }
}

public namespace Math {
    # Some useful constants
    public const M_E = 2.718281828459045235360287471352662497757247093699959574966;
    public const M_PI = 3.141592653589793238462643383279502884197169399375105820974;
    public const M_SQRTPI = 1.772453850905516027298167483341145182797549456122387128213;
    public const M_LOGPI = 1.144729885849400174143427351353058711647294812915311571513;

    #! Return x factorial.
    /**
        @throw "VALUE-ERROR" if x is not integral or is negative
    */
    public number sub factorial (softnumber x) {
        if (x < 0)
            throw "VALUE-ERROR", "factorial() only accepts integral values";
        if (x != floor(x))
            throw "VALUE-ERROR", "factorial() not defined for negative values";
        number r = 1;
        if (x >= 2)
            for (number i=2; i<=x; ++i)
                r *= i;
        return r;
    }

    #! Return the Gamma function at x. Lanczos approximation.
    public float sub gamma (softfloat x) {
        list p = (
                0.99999999999980993, 676.5203681218851, -1259.1392167224028,
                771.32342877765313, -176.61502916214059, 12.507343278686905,
                -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
                );
        int g = 7;

        if (x < 0.5)
            return M_PI / (sin (M_PI * x) * gamma (1-x));

        x -= 1;
        float a = p[0];
        float t = x + g + 0.5;
        for (int i=1; i < p.size(); ++i)
            a += p[i] / (x+i);

        return sqrt(2*M_PI) * pow(t, x+0.5) * exp(-t) * a;
    }

    #! Return the logarithm of x to the given base, calculated as nlog(x)/nlog(base).
    public float sub log (softfloat f, softfloat base = M_E) {
        return nlog(f) / nlog(base);
    }

    #! Return the logarithm of x to the given base, calculated as nlog(x)/nlog(base).
    public number sub log (number n, number base = M_E) {
        return nlog(n) / nlog(base);
    }

    #! Return arithmetic mean ("average") of numeric data.
    /**
        The arithmetic mean is the sum of the data divided by the number of data points.
        It is commonly called “the average”, although it is only one of many different mathematical averages.
        It is a measure of the central location of the data.

        @throw "VALUE-ERROR" if the list is empty
    */
    public any sub mean (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "mean() requires at least one data point";
        return psum(la) / float(n);
    }

    #! Return median (middle value) of numeric data, using the common "mean of middle two" method.
    /**
        The median is a robust measure of central location, and is less affected by the presence of outliers in your data.
        When the number of data points is odd, the middle data point is returned.
        When the number of data points is even, the median is interpolated by taking the average of the two middle values.

        @throw "VALUE-ERROR" if the list is empty

        @see @ref Math::median_low(), @ref Math::median_high()
    */
    public any sub median (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "median() requires at least one data point";
        list s = sort(la);
        if (n % 2 == 1)
            return s[n/2];
        int i = n/2;
        return (s[i-1] + s[i]) / 2.0;
    }

    #! Return the low median of numeric data.
    /**
        When the number of data points is odd, the middle value is returned.
        When it is even, the smaller of the two middle values is returned.

        @throw "VALUE-ERROR" if the list is empty

        @see @ref Math::median_high(), @ref Math::median()
    */
    public any sub median_low (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "median() requires at least one data point";
        list s = sort(la);
        if (n % 2 == 1)
            return s[n/2];
        return s[n/2 - 1];
    }

    #! Return the high median of numeric data.
    /**
        When the number of data points is odd, the middle value is returned.
        When it is even, the larger of the two middle values is returned.

        @throw "VALUE-ERROR" if the list is empty

        @see @ref Math::median_low(), @ref Math::median()
    */
    public any sub median_high (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "median() requires at least one data point";
        list s = sort(la);
        return s[n/2];
    }

    #! Return the most common data point(s) from discrete or nominal data.
    /**
        @throw "VALUE-ERROR" if the list is empty
    */
    public list sub mode (list la) {
        int n = la.size();
        if (n < 1)
            throw "VALUE-ERROR", "mode() requires at least one data point";
        Multiset ms (la);
        list h = ms.most_common();
        int m = h[0][1];
        list r = map $1[0], h, $1[1] == m;
        return r;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        This generic version selects datatype based on either start argument (if used)
        or based on first item of the list.  Use specific versions to force datatype,
        especially when high precision summation of float / number values is required.

        @see @ref Math::isum(), @ref Math::fsum(), @ref Math::nsum(), @ref Math::psum()
    */
    public any sub sum (list la, *any start) {
        map start += $1, la;
        return start ?? 0;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    public int sub isum (list li, int start = 0) {
        map start += $1, li;
        return start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        Full precision summation using multiple floats for intermediate values.
    */
    public float sub fsum (list lf, float start = 0.0) {
        # Rounded x+y stored in hi with the round-off stored in lo.  Together
        # hi+lo are exactly equal to x+y.  The inner loop applies hi/lo summation
        # to each partial so that the list of partial sums remains exact.
        # Depends on IEEE-754 arithmetic guarantees.  See proof of correctness at:
        # www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps

        list partials = (); # sorted, non-overlapping partial sums
        foreach float x in (lf) {
            int i = 0;
            foreach float y in (partials) {
                if (abs(x) < abs(y)) {
                    float a = x; x = y; y = a;
                }
                float hi = x + y;
                float lo = y - (hi - x);
                if (lo) {
                    partials[i] = lo;
                    i += 1;
                }
                x = hi;
            }
            splice partials, i, MAXINT, x;
        }
        float r;
        map r += $1, partials;
        return r + start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    public number sub nsum (list ln, number start = 0n) {
        map start += $1, ln;
        return start;
    }

    #! Sums start and the items of a list and returns the total. start defaults to 0.
    /**
        Full precision summation version of the generic sum() function.

        This generic version selects datatype based on either start argument (if used)
        or based on the first item of the list.

        @see @ref Math::sum(), @ref Math::isum(), @ref Math::fsum(), @ref Math::nsum()
    */
    public any sub psum (list la, *any start) {
        any x = start ?? la[0];
        switch (x.typeCode()) {
            case NT_NUMBER:
                return nsum (la, start ?? 0);
            case NT_FLOAT:
                return fsum (la, start ?? 0);
            case NT_INT:
                return isum (la, start ?? 0);
            default:
                if (start === NOTHING && la.size() == 0)
                    return 0;
                throw "VALUE-ERROR", "sum() only accepts numeric values";
        }
    }
}

# ============================== helper code ==============================

#! Return a new list as 'num' times concatenated 'arg' list.
list sub Math::listmul (softlist arg, softint num) {
    list r = ();
    while (num > 0) {
        r += arg;
        --num;
    }
    return r;
}

/**
    Class for counting hashable items.  Sometimes called a counter or bag or multiset.

    @see http://en.wikipedia.org/wiki/Multiset
*/
public class Math::AbstractMultiset {
    private {
    }

    constructor (any x) {
        self.update(x);
    }

    abstract update (Qore::ListIterator x);
    abstract update (Qore::HashPairIterator x);

    abstract subtract (Qore::ListIterator x);
    abstract subtract (Qore::HashPairIterator x);

    update (list x) {
        self.update (x.iterator());
    }

    update (hash x) {
        self.update (x.pairIterator());
    }

    update (AbstractMultiset x) {
        self.update (x.elems().iterator());
    }

    subtract (list x) {
        self.subtract (x.iterator());
    }

    subtract (hash x) {
        self.subtract (x.pairIterator());
    }

    subtract (AbstractMultiset x) {
        self.subtract (x.elems().iterator());
    }

    abstract clear ();
    abstract int count (any x);
    abstract list elems ();
    abstract hash items ();
    abstract list most_common (*int n);
}

/**
    Class for counting hashable items.  Sometimes called a counter or bag or multiset.
    Elements are indexed as hash keys and their {type, value, count} are stored as hash values.

    @note This class is slower than @ref Math::UnsafeMultiset but it is safe to be used with values other than strings.

    @see http://en.wikipedia.org/wiki/Multiset
*/
public class Math::Multiset inherits Math::AbstractMultiset {
    private {
        hash _h = {}; # consists of hashes with keys 'count', 'value', 'type'
    }

    constructor (any x) : AbstractMultiset (x) {
    }

    update (Qore::ListIterator x) {
        foreach any item in (x) {
            string k = item.toString();
            if (!exists _h.(k)) {
                _h.(k) = { 'count': 1, 'value': item, 'type': item.typeCode() };
                continue;
            }
            reference r = \_h.(k);
            if (r.type != item.typeCode() || r.value != item)
                throw "MULTISET-ERROR", sprintf ("cannot safely handle %s %y -- multiset already contains %s %y",
                                                 item.type(), item, TypeCodeMap.(r.type), r.value);
            r.count += 1;
        }
    }

    update (Qore::HashPairIterator x) {
        foreach hash h in (x) {
            string k = h.key;
            if (!exists _h.(k)) {
                _h.(k) = { 'count': h.value, 'value': k, 'type': k.typeCode() };
                continue;
            }
            reference r = \_h.(k);
            if (r.type != k.typeCode() || r.value != k)
                throw "MULTISET-ERROR", sprintf ("cannot safely handle %s %y -- multiset already contains %s %y",
                                                 k.type(), k, TypeCodeMap.(r.type), r.value);
            r.count += h.value;
        }
    }

    subtract (Qore::ListIterator x) {
        foreach any item in (x) {
            string k = item.toString();
            if (!exists _h.(k)) {
                _h.(k) = { 'count': -1, 'value': item, 'type': item.typeCode() };
                continue;
            }
            reference r = \_h.(k);
            if (r.type != item.typeCode() || r.value != item)
                throw "MULTISET-ERROR", sprintf ("cannot safely handle %s %y -- multiset already contains %s %y",
                                                 item.type(), item, TypeCodeMap.(r.type), r.value);
            r.count += -1;
        }
    }

    subtract (Qore::HashPairIterator x) {
        foreach hash h in (x) {
            string k = h.key;
            if (!exists _h.(k)) {
                _h.(k) = { 'count': -h.value, 'value': k, 'type': k.typeCode() };
                continue;
            }
            reference r = \_h.(k);
            if (r.type != k.typeCode() || r.value != k)
                throw "MULTISET-ERROR", sprintf ("cannot safely handle %s %y -- multiset already contains %s %y",
                                                 k.type(), k, TypeCodeMap.(r.type), r.value);
            r.count += -h.value;
        }
    }

    #! Remove all elements from the multiset.
    clear () {
        _h = {};
    }

    #! Return number of occurrences of an element.
    int count (any x) {
        int c = _h.(x.toString()).count ?? 0;
        return c > 0 ? c : 0;
    }

    #! Return all elements repeating each as many times as its count.
    list elems () {
        list r = ();
        map r += listmul ($1.value, $1.count), _h.iterator();
        return r;
    }

    #! Return internal hash structure. Note: not part of API; implementation specific (!)
    hash items () {
        return _h;
    }

    #! Return the n most common elements and their counts from the most common to the least.
    /**
        Return the n most common elements and their counts from the most common to the least.
        If n is omitted or NOTHING, then return all element counts.
    */
    list most_common (*int n) {
        list x = map ($1.value, $1.count), _h.iterator();
        code f = int sub (list l, list r) { return l[1] <=> r[1]; };
        list s = sort_descending_stable (x, f);
        if (exists n)
            if (n >= 0)
                splice s, n;
            else if (-n < s.size())
                splice s, 0, s.size() + n;
        return s;
    }
}

/**
    Class for counting hashable items.  Sometimes called a counter or bag or multiset.
    Elements are stored as hash keys and their counts are stored as hash values.

    @note This class is faster than @ref Math::Multiset but it is not safe to be used with values other than strings.

    @see http://en.wikipedia.org/wiki/Multiset
*/
public class Math::UnsafeMultiset inherits Math::AbstractMultiset {
    private {
        hash _h = {};
    }

    constructor (any x) : AbstractMultiset (x) {
    }

    update (Qore::ListIterator x) {
        map _h.($1.toString()) += 1, x;
    }

    update (Qore::HashPairIterator x) {
        map _h.($1.key) += $1.value, x;
    }

    subtract (Qore::ListIterator x) {
        map _h.($1.toString()) -= 1, x;
    }

    subtract (Qore::HashPairIterator x) {
        map _h.($1.key) -= $1.value, x;
    }

    #! Remove all elements from the multiset.
    clear () {
        _h = {};
    }

    #! Return number of occurrences of an element.
    int count (any x) {
        int c = _h.(x.toString()) ?? 0;
        return c > 0 ? c : 0;
    }

    #! Return all elements repeating each as many times as its count.
    list elems () {
        list r = ();
        map r += listmul ($1.key, $1.value), _h.pairIterator();
        return r;
    }

    #! Return internal hash structure. Note: not part of API; implementation specific (!)
    hash items () {
        return _h;
    }

    #! Return the n most common elements and their counts from the most common to the least.
    /**
        Return the n most common elements and their counts from the most common to the least.
        If n is omitted or NOTHING, then return all element counts.
    */
    list most_common (*int n) {
        list x = map ($1.key, $1.value), _h.pairIterator();
        code f = int sub (list l, list r) { return l[1] <=> r[1]; };
        list s = sort_descending_stable (x, f);
        if (exists n)
            if (n >= 0)
                splice s, n;
            else if (-n < s.size())
                splice s, 0, s.size() + n;
        return s;
    }
}

# vim:et:sw=4:ts=4:sts=4:
