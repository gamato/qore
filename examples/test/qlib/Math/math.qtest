#!/usr/bin/env qore

%requires ../../../../qlib/Math.qm
%requires ../../../../qlib/QUnit.qm

%new-style
%require-types
%enable-all-warnings

%exec-class MathTest

list sub hash2list (*hash x) {
    return map ($1.key, $1.value), x.pairIterator();
}

hash sub list2hash (*list x) {
    return map {$1[0]: $1[1]}, x.iterator();
}

list sub str2list (*string x) {
    if (x.size() == 0)
        return ();
    return map x[$1], xrange (x.size() - 1);
}

#! Returns a new list as 'num' times concatenated 'arg' list.
list sub listmul (softlist arg, softint num) {
    list r = ();
    while (num > 0) {
        r += arg;
        --num;
    }
    return r;
}


public class MathTest inherits QUnit::Test {
    constructor() : Test ("MathTest", "1.0") {
        addTestCase ("Test hash/list/string helper functions", \test_hash_list_string());
        addTestCase ("Test listmul helper function", \test_listmul());
        addTestCase ("Test Set classes", \test_set());
        addTestCase ("Test Multiset classes", \test_multiset());
        addTestCase ("Test factorial function", \test_factorial());
        addTestCase ("Test gamma function", \test_gamma());
        addTestCase ("Test log function", \test_log());
        addTestCase ("Test mean function", \test_mean());
        addTestCase ("Test median functions", \test_median());
        addTestCase ("Test mode function", \test_mode());
        addTestCase ("Test sum functions", \test_sum());
        set_return_value(main());
    }

    test_hash_list_string() {
        hash h = {'a':1, 'b':2};
        list l = (('a',1), ('b',2));
        assertEq (l, hash2list(h), "hash2list: non-empty input");
        assertEq (h, list2hash(l), "list2hash: non-empty input");
        assertEq ((), hash2list({}), "hash2list: empty input");
        assertEq ({}, list2hash(()), "list2hash: empty input");
        assertEq ((), hash2list(), "hash2list: no value input");
        assertEq ({}, list2hash(), "list2hash: no value input");
        assertEq (('a','b','c'), str2list("abc"), "str2list: non-empty input");
        assertEq ((), str2list(""), "str2list: empty input");
        assertEq ((), str2list(), "str2list: no value input");
    }

    test_listmul() {
        assertEq (list(), listmul ((), 2), "listmul: empty list");
        assertEq (list(), listmul ((1,2), 0), "listmul: num=0");
        assertEq ((1,2), listmul ((1,2), 1), "listmul: num=1");
        assertEq ((1,2,1,2,1,2), listmul ((1,2), 3), "listmul: num>1");
    }

    test_set() {
        _test_sets ("Set", any sub (any arg) { return new Set (arg); });
        _test_sets ("UnsafeSet", any sub (any arg) { return new UnsafeSet (arg); });
    }

    _test_sets (string class_name, code class_creator) {
        list x = ('a', 'b', 'c', 'a', 'b', 'a');
        list exp = ('a', 'b', 'c');
        any c = class_creator (x);
        any c1 = class_creator (x);
        any c2 = class_creator (('c', 'd', 'e'));
        any c3 = class_creator (('d', 'e', 'f'));
        # elements + iterators
        assertEq (exp, sort(c.items()), class_name + ": items");
        assertEq (c.items(), (map $1, c.item_iterator()), class_name + ": item_iterator");
        # constructors
        assertEq (list(), class_creator().items(), class_name + ": create from nothing");
        assertEq (exp, class_creator(x).items(), class_name + ": create from list");
        assertEq (exp, class_creator(x.iterator()).items(), class_name + ": create from list iterator");
        assertEq (exp, class_creator(c.item_iterator()).items(), class_name + ": create from item_iterator");
        assertEq (exp, class_creator(class_creator(x)).items(), class_name + ": create from " + class_name);
        # add + merge
        c.add ('d');
        c.merge (listmul('a', 300) + listmul('b', 200));
        c.merge (c2);
        assertEq (('a', 'b', 'c', 'd', 'e'), sort(c.items()), class_name + ": add + merge");
        # discard + subtract
        c.discard ('d');
        c.subtract (listmul('a', 300) + listmul('b', 200));
        c.subtract (c2);
        assertEq (list(), c.items(), class_name + ": discard + subtract");
        c = class_creator (x);
        c.subtract (c);
        assertEq (list(), c.items(), class_name + ": subtract itself - items");
        assertEq (list(), (map $1, c.item_iterator()), class_name + ": subtract itself - item_iterator");
        # intersect
        c = class_creator (x);
        c.intersect (c2);
        c.intersect (('a', 'b', 'c'));
        assertEq (('c',), sort(c.items()), class_name + ": intersect");
        # symmetric_subtract
        c = class_creator (x);
        c.symmetric_subtract (c2);
        c.symmetric_subtract (('d', 'e', 'f'));
        assertEq (('a', 'b', 'f'), sort(c.items()), class_name + ": symmetric_subtract");
        # intersection + union + difference + symmetric_difference
        c = class_creator (x);
        assertEq (('c',), sort(c.intersection(c2).items()), class_name + ": intersection");
        assertEq (('a', 'b', 'c', 'd', 'e'), sort(c.union(c2).items()), class_name + ": union");
        assertEq (('a', 'b'), sort(c.difference(c2).items()), class_name + ": difference");
        assertEq (('a', 'b', 'd', 'e'), sort(c.symmetric_difference(c2).items()), class_name + ": symmetric_difference");
        # equals + isdisjoint + issubset + issuperset
        c = class_creator (x);
        assertTrue (c.equals (c1), class_name + ": equals");
        assertFalse (c.equals (c2), class_name + ": not equals");
        assertTrue (c.isdisjoint (c3), class_name + ": is disjoint");
        assertFalse (c.isdisjoint (c2), class_name + ": is not disjoint");
        assertTrue (c.issubset (c1), class_name + ": is subset");
        assertFalse (c.issubset (c2), class_name + ": is not subset");
        assertTrue (c.issuperset (c1), class_name + ": is superset");
        assertFalse (c.issuperset (c2), class_name + ": is not superset");
        # contains + count + size + empty
        c = class_creator (x);
        assertTrue (c.contains('a'), class_name + ": contains existing");
        assertFalse (c.contains('x'), class_name + ": contains missing");
        assertFalse (c.contains(), class_name + ": contains no value");
        assertEq (1, c.count('a'), class_name + ": count existing");
        assertEq (0, c.count('x'), class_name + ": count missing");
        assertEq (0, c.count(), class_name + ": count no value");
        assertEq (3, c.size(), class_name + ": size");
        assertFalse (c.empty(), class_name + ": empty");
        # clear + empty
        c.clear();
        assertTrue (c.empty(), class_name + ": clear - empty");
        assertEq (0, c.size(), class_name + ": clear - size");
        assertEq ((), c.items(), class_name + ": clear - items");
        assertEq ((), (map $1, c.item_iterator()), class_name + ": clear - item_iterator");
        # performance testing
        # printf("%y\n", now_us());
        # c = class_creator (range(int(10e4)));
        # printf("class_creator (range()):\n%y\n", now_us());
        # printf("%y\n", c.size());
        # printf("c.size():\n%y\n", now_us());
        # printf("%y\n", c.count());
        # printf("c.count():\n%y\n", now_us());
        # c1 = class_creator (c.item_iterator());
        # printf("class_creator (c.item_iterator()):\n%y\n", now_us());
        # c2 = class_creator (c);
        # printf("class_creator (c):\n%y\n", now_us());
        # printf("%y\n", c.intersection(c1).size());
        # printf("c.intersection():\n%y\n", now_us());
        # printf("%y\n", c.union(c1).size());
        # printf("c.union():\n%y\n", now_us());
        # printf("%y\n", c.difference(c1).size());
        # printf("c.difference():\n%y\n", now_us());
        # printf("%y\n", c.symmetric_difference(c1).size());
        # printf("c.symmetric_difference():\n%y\n", now_us());
        # c.merge(c1);
        # printf("c.merge():\n%y\n", now_us());
        # c.equals(c1);
        # printf("c.equals():\n%y\n", now_us());
        # c.intersect(c1);
        # printf("c.intersect():\n%y\n", now_us());
        # printf("%y\n", c.isdisjoint(c1));
        # printf("c.isdisjoint():\n%y\n", now_us());
        # printf("%y\n", c.issubset(c1));
        # printf("c.issubset():\n%y\n", now_us());
        # printf("%y\n", c.issuperset(c1));
        # printf("c.issuperset():\n%y\n", now_us());
        # c.subtract(c1);
        # printf("c.subtract():\n%y\n", now_us());
        # c1.symmetric_subtract(c2);
        # printf("c.symmetric_subtract():\n%y\n", now_us());
    }

    test_multiset() {
        _test_multisets ("Multiset", any sub (any arg) { return new Multiset (arg); });
        _test_multisets ("UnsafeMultiset", any sub (any arg) { return new UnsafeMultiset (arg); });
    }

    _test_multisets (string class_name, code class_creator) {
        list x = ('a', 'b', 'c', 'a', 'b', 'a');
        hash exp = {'a': 3, 'b': 2, 'c': 1};
        any c = class_creator (x);
        any c1 = class_creator (x);
        any c2 = class_creator ({'c': 3, 'd': 2, 'e': 1});
        # elements + iterators
        assertEq (sort(x), sort(c.items()), class_name + ": items");
        assertEq (hash2list(exp), c.pairs(), class_name + ": pairs");
        assertEq (c.items(), (map $1, c.item_iterator()), class_name + ": item_iterator");
        assertEq (c.pairs(), (map $1, c.pair_iterator()), class_name + ": pair_iterator");
        # constructors
        assertEq (list(), class_creator().items(), class_name + ": create from nothing");
        assertEq (sort(x), class_creator(x).items(), class_name + ": create from list");
        assertEq (sort(x), class_creator(x.iterator()).items(), class_name + ": create from list iterator");
        assertEq (sort(x), class_creator(exp).items(), class_name + ": create from hash");
        assertEq (sort(x), class_creator(exp.pairIterator()).items(), class_name + ": create from hash iterator");
        assertEq (sort(x), class_creator(c.item_iterator()).items(), class_name + ": create from item_iterator");
        assertEq (sort(x), class_creator(c.pair_iterator()).items(), class_name + ": create from pair_iterator");
        assertEq (sort(x), class_creator(class_creator(x)).items(), class_name + ": create from " + class_name);
        # most_common
        assertEq (hash2list(exp), c.most_common(), class_name + ": most_common()");
        assertEq (hash2list({}), c.most_common(0), class_name + ": most_common(0)");
        foreach int i in (range(1, c.pairs().size() + 1)) {
            list kp = list km = map $1[0].toString(), c.pairs(); # c.dump().keys()
            splice kp, i;
            km = extract km, -i;
            assertEq (hash2list(exp.(kp)), c.most_common(i), sprintf ("%s: most_common(%d)", class_name, i));
            assertEq (hash2list(exp.(km)), c.most_common(-i), sprintf ("%s: most_common(%d)", class_name, -i));
        }
        # add + merge
        c.add ('d');
        c.merge ({'a': 30, 'b': 20});
        c.merge (listmul('a', 300) + listmul('b', 200));
        assertEq ((('a', 333), ('b', 222), ('c', 1), ('d', 1)), c.most_common(), class_name + ": add + merge");
        # discard + subtract
        c.discard ('d');
        c.subtract ({'a': 30, 'b': 20});
        c.subtract (listmul('a', 300) + listmul('b', 200));
        assertEq (sort(x), sort(c.items()), class_name + ": discard + subtract");
        c.subtract (x);
        assertEq (list(), c.items(), class_name + ": subtract to zero - items");
        assertEq (list(), c.pairs(), class_name + ": subtract to zero - pairs");
        assertEq (list(), (map $1, c.item_iterator()), class_name + ": subtract to zero - item_iterator");
        assertEq (list(), (map $1, c.pair_iterator()), class_name + ": subtract to zero - pair_iterator");
        assertEq ((('a', 0), ('b', 0), ('c', 0), ('d', 0)), c.most_common(), class_name + ": subtract to zero - most_common");
        # equals
        c = class_creator (x);
        assertTrue (c.equals (c1), class_name + ": equals");
        assertFalse (c.equals (c2), class_name + ": not equals");
        # contains + count + size + empty
        assertTrue (c.contains('a'), class_name + ": contains existing");
        assertFalse (c.contains('x'), class_name + ": contains missing");
        assertFalse (c.contains(), class_name + ": contains no value");
        assertEq (3, c.count('a'), class_name + ": count existing");
        assertEq (0, c.count('x'), class_name + ": count missing");
        assertEq (0, c.count(), class_name + ": count no value");
        assertEq (6, c.size(), class_name + ": size");
        assertFalse (c.empty(), class_name + ": empty");
        # clear + empty
        c.clear();
        assertTrue (c.empty(), class_name + ": clear - empty");
        assertEq (0, c.size(), class_name + ": clear - size");
        assertEq ((), c.items(), class_name + ": clear - items");
        assertEq ((), c.pairs(), class_name + ": clear - pairs");
        assertEq ((), (map $1, c.item_iterator()), class_name + ": clear - item_iterator");
        assertEq ((), (map $1, c.pair_iterator()), class_name + ": clear - pair_iterator");
        # performance testing
        # printf("%y\n", now_us());
        # c = class_creator (range(int(10e4)));
        # printf("class_creator (range()):\n%y\n", now_us());
        # printf("%y\n", c.size());
        # printf("c.size():\n%y\n", now_us());
        # printf("%y\n", c.count());
        # printf("c.count():\n%y\n", now_us());
        # c1 = class_creator (c.item_iterator());
        # printf("class_creator (c.item_iterator()):\n%y\n", now_us());
        # c2 = class_creator (c.pair_iterator());
        # printf("class_creator (c.pair_iterator()):\n%y\n", now_us());
        # c = class_creator (c);
        # printf("class_creator (c):\n%y\n", now_us());
        # c.merge(c1);
        # printf("c.merge():\n%y\n", now_us());
        # c.equals(c1);
        # printf("c.equals():\n%y\n", now_us());
        # printf("%y\n", c.most_common().size());
        # printf("c.most_common():\n%y\n", now_us());
        # c.subtract(c1);
        # printf("c.subtract():\n%y\n", now_us());
    }

    test_factorial() {
        assertEq (1n, factorial(0), "factorial(0)");
        number total = 1;
        for (int i=1; i<=100; ++i) {
            total *= i;
            assertEq (total, factorial(i), sprintf ("factorial(%d)", i));
        }
        code kod = sub () { call_function_args ('factorial', argv); };
        assertThrows ("VALUE-ERROR", kod, -1, "factorial(-1)");
        assertThrows ("VALUE-ERROR", kod, -1.0, "factorial(-1.0)");
        assertThrows ("VALUE-ERROR", kod, -pow(10, 100), "factorial(-10^100)");
        assertThrows ("VALUE-ERROR", kod, -1e100, "factorial(-1e100)");
        assertThrows ("VALUE-ERROR", kod, M_PI, "factorial(pi)");
    }

    test_gamma() {
        list r = (
                2.67893853, 1.35411794, 1.00000000, 0.89297951, 0.90274529,
                1.00000000, 1.19063935, 1.50457549, 2.00000000, 2.77815848,
                );
        for (float x=1.0; x <= 10.0; x+=1.0)
            assertFloatEq (r[x-1], gamma (x/3.0), 0.00000001, sprintf ("gamma #%d", x));
    }

    test_log() {
        float eps = 0.0000000001;
        assertFloatEq (-1, log (1/M_E), eps, 'log(1/e)');
        assertFloatEq (0, log (1.0), eps, 'log(1)');
        assertFloatEq (1, log (M_E), eps, 'log(e)');
        assertFloatEq (5, log (32.0, 2), eps, 'log(32, 2)');
        assertFloatEq (40, log (pow(10.0, 40), 10), eps, 'log(10^40, 10)');
        assertFloatEq (2, log (pow(10.0, 40), pow(10.0, 20)), eps, 'log(10^40, 10^20)');
        assertNumberEq (2302.5850929940457, log (pow(10n, 1000)), eps, 'log(10^1000)');
        assertTrue (log(-1.5).nanp(), 'log(-1.5)');
        assertTrue (log(-pow(10.0, 1000)).nanp(), 'log(-(10^1000))');
        assertTrue (log(-@Inf@).nanp(), 'log(-@INF@)');
        assertTrue (log(@Inf@).infp(), 'log(+@INF@)');
        assertTrue (log(@NaN@).nanp(), 'log(@NAN@)');
    }

    test_mean() {
        list x;
        # Test mean with ints
        x = (0, 1, 2, 3, 3, 3, 4, 5, 5, 6, 7, 7, 7, 7, 8, 9);
        assertEq (4.8125, mean(x), "mean: integers");
        # Test mean with floats
        x = (17.25, 19.75, 20.0, 21.5, 21.75, 23.25, 25.125, 27.5);
        assertEq (22.015625, mean(x), "mean: floats");
        # Test mean with numbers
        x = (1.634n, 2.517n, 3.912n, 4.072n, 5.813n);
        assertNumberEq (3.5896n, mean(x), 1e-10, "mean: numbers");
        # Test mean with empty list
        code kod = sub () { call_function_args ('mean', argv); };
        assertThrows ("VALUE-ERROR", kod, ((),), "mean: empty list");
        # Mean of (a,b,c...z) should be same as for (a,a,b,b,c,c...z,z)
        x = range(1000);
        assertEq (mean(x), mean (listmul (x,2)), "mean: doubled list");
        # Test adding a large constant to every data point
        float c = 1e9;
        x = (3.4, 4.5, 4.9, 6.7, 6.8, 7.2, 8.0, 8.1, 9.4);
        float exp = mean(x) + c;
        assertTrue (exp != c);
        assertEq (exp, mean (map $1+c, x), "mean: list + large constant");
        # Try to exploit lack of precision of 64-bit float
        x = (1e100, 1, 3, -1e100);
        assertEq (1.0, mean(x), "mean: full precision");
    }

    test_median() {
        list x;
        # Test median with an even number of int data points
        x = (1, 2, 3, 4, 5, 6);
        assertEq (0, x.size() % 2);
        assertEq (3.5, median(x), "median: even count");
        # Test median with an odd number of int data points
        x = (1, 2, 3, 4, 5, 6, 7);
        assertEq (1, x.size() % 2);
        assertEq (4, median(x), "median: odd count");

        x = (1, 2, 3, 4, 5, 6);
        assertEq (0, x.size() % 2);
        # Test median_low with an even number of ints
        assertEq (3, median_low(x), "median_low");
        # Test median_high with an even number of ints
        assertEq (4, median_high(x), "median_high");
    }

    test_mode() {
        list x;
        x = str2list ("abcbdb");
        assertEq (("b",), mode(x), "mode: letters");
        x = "fe fi fo fum fi fi".split(" ");
        assertEq (("fi",), mode(x), "mode: words");
        x = range(10);
        foreach int i in (range(10))
            assertEq ((i,), mode (x + i), "mode: discrete data #" + i);
        x = (1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 6, 6, 6, 7, 8, 9, 9);
        assertEq ((2,6), mode(x), "mode: bimodal data");
        x = range(666);
        assertEq (x.size(), mode(x).size(), "mode: unique data");
        code kod = sub () { call_function_args ('mode', argv); };
        assertThrows ("VALUE-ERROR", kod, ((),), "mode: no data");
    }

    test_sum() {
        list x;
        # generic function
        assertEq (50005000, sum (range (10000)), "sum: integers");
        assertEq (0.0, sum (listmul ((1.0, 1e100, 1.0, -1e100), 10000)), "sum: floats"); # NOTE: exploits lack of precision of 64-bit float
        assertEq (20000n, sum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "sum: numbers");
        # generic high precision function
        assertEq (50005000, psum (range (10000)), "psum: integers");
        assertEq (20000.0, psum (listmul ((1.0, 1e100, 1.0, -1e100), 10000)), "psum: floats");
        assertEq (20000n, psum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "psum: numbers");
        # specialised functions
        assertEq (50005000, isum (range (10000)), "isum");
        assertEq (20000.0, fsum (listmul ((1, 1e100, 1, -1e100), 10000)), "fsum");
        assertEq (20000n, nsum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "nsum");
        # start != 0
        x = range(10);
        assertEq (56, sum (x, 1), "sum: start != 0");
        assertEq (56, isum (x, 1), "isum: start != 0");
        assertEq (56.0, fsum (x, 1), "fsum: start != 0");
        assertEq (56n, nsum (x, 1), "nsum: start != 0");
        assertEq (56, psum (x, 1), "psum: start != 0");
        # empty list
        x = ();
        assertEq (0, sum (x), "sum: empty list");
        assertEq (0, isum (x), "isum: empty list");
        assertEq (0.0, fsum (x), "fsum: empty list");
        assertEq (0n, nsum (x), "nsum: empty list");
        assertEq (0, psum (x), "psum: empty list");
    }
}
