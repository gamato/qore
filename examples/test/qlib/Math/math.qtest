#!/usr/bin/env qore

%requires ../../../../qlib/Math.qm
%requires ../../../../qlib/QUnit.qm

%new-style
%require-types
%enable-all-warnings

%exec-class MathTest

list sub hash2list (*hash x) {
    return map ($1.key, $1.value), x.pairIterator();
}

hash sub list2hash (*list x) {
    return map {$1[0]: $1[1]}, x.iterator();
}

list sub str2list (*string x) {
    if (x.size() == 0)
        return ();
    return map x[$1], xrange (x.size() - 1);
}

#! Returns a new list as 'num' times concatenated 'arg' list.
list sub listmul (softlist arg, softint num) {
    list r = ();
    while (num > 0) {
        r += arg;
        --num;
    }
    return r;
}


public class MathTest inherits QUnit::Test {
    constructor() : Test ("MathTest", "1.0") {
        addTestCase ("Test hash/list/string helper functions", \test_hash_list_string());
        addTestCase ("Test listmul helper function", \test_listmul());
        addTestCase ("Test Multiset classes", \test_multiset());
        addTestCase ("Test factorial function", \test_factorial());
        addTestCase ("Test gamma function", \test_gamma());
        addTestCase ("Test log function", \test_log());
        addTestCase ("Test mean function", \test_mean());
        addTestCase ("Test median functions", \test_median());
        addTestCase ("Test mode function", \test_mode());
        addTestCase ("Test sum functions", \test_sum());
        set_return_value(main());
    }

    test_hash_list_string() {
        hash h = {'a':1, 'b':2};
        list l = (('a',1), ('b',2));
        assertEq (l, hash2list(h), "hash2list: non-empty input");
        assertEq (h, list2hash(l), "list2hash: non-empty input");
        assertEq ((), hash2list({}), "hash2list: empty input");
        assertEq ({}, list2hash(()), "list2hash: empty input");
        assertEq ((), hash2list(), "hash2list: no value input");
        assertEq ({}, list2hash(), "list2hash: no value input");
        assertEq (('a','b','c'), str2list("abc"), "str2list: non-empty input");
        assertEq ((), str2list(""), "str2list: empty input");
        assertEq ((), str2list(), "str2list: no value input");
    }

    test_listmul() {
        assertEq (list(), listmul ((), 2), "listmul: empty list");
        assertEq (list(), listmul ((1,2), 0), "listmul: num=0");
        assertEq ((1,2), listmul ((1,2), 1), "listmul: num=1");
        assertEq ((1,2,1,2,1,2), listmul ((1,2), 3), "listmul: num>1");
    }

    test_multiset() {
        _test_multisets ("Multiset", any sub (any arg) { return new Multiset (arg); });
        _test_multisets ("UnsafeMultiset", any sub (any arg) { return new UnsafeMultiset (arg); });
    }

    _test_multisets (string class_name, code class_creator) {
        list x = ('a', 'b', 'c', 'a', 'b', 'a');
        hash exp = {'a': 3, 'b': 2, 'c': 1};
        any c = class_creator (x);
        # elements + iterators
        assertEq (sort(x), sort(c.items()), class_name + ": items");
        assertEq (hash2list(exp), c.pairs(), class_name + ": pairs");
        assertEq (c.items(), (map $1, c.item_iterator()), class_name + ": item_iterator");
        assertEq (c.pairs(), (map $1, c.pair_iterator()), class_name + ": pair_iterator");
        # constructors
        assertEq (list(), class_creator().items(), class_name + ": create from nothing");
        assertEq (sort(x), class_creator(x).items(), class_name + ": create from list");
        assertEq (sort(x), class_creator(x.iterator()).items(), class_name + ": create from list iterator");
        assertEq (sort(x), class_creator(exp).items(), class_name + ": create from hash");
        assertEq (sort(x), class_creator(exp.pairIterator()).items(), class_name + ": create from hash iterator");
        assertEq (sort(x), class_creator(c.item_iterator()).items(), class_name + ": create from item_iterator");
        assertEq (sort(x), class_creator(c.pair_iterator()).items(), class_name + ": create from pair_iterator");
        assertEq (sort(x), class_creator(class_creator(x)).items(), class_name + ": create from " + class_name);
        # most_common
        assertEq (hash2list(exp), c.most_common(), class_name + ": most_common()");
        assertEq (hash2list({}), c.most_common(0), class_name + ": most_common(0)");
        foreach int i in (range(1, c.pairs().size() + 1)) {
            list kp = list km = map $1[0].toString(), c.pairs(); # c.dump().keys()
            splice kp, i;
            km = extract km, -i;
            assertEq (hash2list(exp.(kp)), c.most_common(i), sprintf ("%s: most_common(%d)", class_name, i));
            assertEq (hash2list(exp.(km)), c.most_common(-i), sprintf ("%s: most_common(%d)", class_name, -i));
        }
        # add + update
        c.add ('d');
        c.update ({'a': 30, 'b': 20});
        c.update (listmul('a', 300) + listmul('b', 200));
        assertEq ((('a', 333), ('b', 222), ('c', 1), ('d', 1)), c.most_common(), class_name + ": add + update");
        # discard + subtract
        c.discard ('d');
        c.subtract ({'a': 30, 'b': 20});
        c.subtract (listmul('a', 300) + listmul('b', 200));
        assertEq (sort(x), sort(c.items()), class_name + ": discard + subtract");
        c.subtract (x);
        assertEq (list(), c.items(), class_name + ": subtract to zero - items");
        assertEq (list(), c.pairs(), class_name + ": subtract to zero - pairs");
        assertEq (list(), (map $1, c.item_iterator()), class_name + ": subtract to zero - item_iterator");
        assertEq (list(), (map $1, c.pair_iterator()), class_name + ": subtract to zero - pair_iterator");
        assertEq ((('a', 0), ('b', 0), ('c', 0), ('d', 0)), c.most_common(), class_name + ": subtract to zero - most_common");
        # count + size
        c = class_creator (x);
        assertEq (3, c.count('a'), class_name + ": count existing");
        assertEq (0, c.count('x'), class_name + ": count missing");
        assertEq (0, c.count(), class_name + ": count no value");
        assertEq (6, c.size(), class_name + ": size");
        # clear
        c.clear();
        assertEq (0, c.size(), class_name + ": clear - size");
        assertEq ((), c.items(), class_name + ": clear - items");
        assertEq ((), c.pairs(), class_name + ": clear - pairs");
        assertEq ((), (map $1, c.item_iterator()), class_name + ": clear - item_iterator");
        assertEq ((), (map $1, c.pair_iterator()), class_name + ": clear - pair_iterator");
    }

    test_factorial() {
        assertEq (1n, factorial(0), "factorial(0)");
        number total = 1;
        for (int i=1; i<=100; ++i) {
            total *= i;
            assertEq (total, factorial(i), sprintf ("factorial(%d)", i));
        }
        code kod = sub () { call_function_args ('factorial', argv); };
        assertThrows ("VALUE-ERROR", kod, -1, "factorial(-1)");
        assertThrows ("VALUE-ERROR", kod, -1.0, "factorial(-1.0)");
        assertThrows ("VALUE-ERROR", kod, -pow(10, 100), "factorial(-10^100)");
        assertThrows ("VALUE-ERROR", kod, -1e100, "factorial(-1e100)");
        assertThrows ("VALUE-ERROR", kod, M_PI, "factorial(pi)");
    }

    test_gamma() {
        list r = (
                2.67893853, 1.35411794, 1.00000000, 0.89297951, 0.90274529,
                1.00000000, 1.19063935, 1.50457549, 2.00000000, 2.77815848,
                );
        for (float x=1.0; x <= 10.0; x+=1.0)
            assertFloatEq (r[x-1], gamma (x/3.0), 0.00000001, sprintf ("gamma #%d", x));
    }

    test_log() {
        float eps = 0.0000000001;
        assertFloatEq (-1, log (1/M_E), eps, 'log(1/e)');
        assertFloatEq (0, log (1.0), eps, 'log(1)');
        assertFloatEq (1, log (M_E), eps, 'log(e)');
        assertFloatEq (5, log (32.0, 2), eps, 'log(32, 2)');
        assertFloatEq (40, log (pow(10.0, 40), 10), eps, 'log(10^40, 10)');
        assertFloatEq (2, log (pow(10.0, 40), pow(10.0, 20)), eps, 'log(10^40, 10^20)');
        assertNumberEq (2302.5850929940457, log (pow(10n, 1000)), eps, 'log(10^1000)');
        assertTrue (log(-1.5).nanp(), 'log(-1.5)');
        assertTrue (log(-pow(10.0, 1000)).nanp(), 'log(-(10^1000))');
        assertTrue (log(-@Inf@).nanp(), 'log(-@INF@)');
        assertTrue (log(@Inf@).infp(), 'log(+@INF@)');
        assertTrue (log(@NaN@).nanp(), 'log(@NAN@)');
    }

    test_mean() {
        list x;
        # Test mean with ints
        x = (0, 1, 2, 3, 3, 3, 4, 5, 5, 6, 7, 7, 7, 7, 8, 9);
        assertEq (4.8125, mean(x), "mean: integers");
        # Test mean with floats
        x = (17.25, 19.75, 20.0, 21.5, 21.75, 23.25, 25.125, 27.5);
        assertEq (22.015625, mean(x), "mean: floats");
        # Test mean with numbers
        x = (1.634n, 2.517n, 3.912n, 4.072n, 5.813n);
        assertNumberEq (3.5896n, mean(x), 1e-10, "mean: numbers");
        # Test mean with empty list
        code kod = sub () { call_function_args ('mean', argv); };
        assertThrows ("VALUE-ERROR", kod, ((),), "mean: empty list");
        # Mean of (a,b,c...z) should be same as for (a,a,b,b,c,c...z,z)
        x = range(1000);
        assertEq (mean(x), mean (listmul (x,2)), "mean: doubled list");
        # Test adding a large constant to every data point
        float c = 1e9;
        x = (3.4, 4.5, 4.9, 6.7, 6.8, 7.2, 8.0, 8.1, 9.4);
        float exp = mean(x) + c;
        assertTrue (exp != c);
        assertEq (exp, mean (map $1+c, x), "mean: list + large constant");
        # Try to exploit lack of precision of 64-bit float
        x = (1e100, 1, 3, -1e100);
        assertEq (1.0, mean(x), "mean: full precision");
    }

    test_median() {
        list x;
        # Test median with an even number of int data points
        x = (1, 2, 3, 4, 5, 6);
        assertEq (0, x.size() % 2);
        assertEq (3.5, median(x), "median: even count");
        # Test median with an odd number of int data points
        x = (1, 2, 3, 4, 5, 6, 7);
        assertEq (1, x.size() % 2);
        assertEq (4, median(x), "median: odd count");

        x = (1, 2, 3, 4, 5, 6);
        assertEq (0, x.size() % 2);
        # Test median_low with an even number of ints
        assertEq (3, median_low(x), "median_low");
        # Test median_high with an even number of ints
        assertEq (4, median_high(x), "median_high");
    }

    test_mode() {
        list x;
        x = str2list ("abcbdb");
        assertEq (("b",), mode(x), "mode: letters");
        x = "fe fi fo fum fi fi".split(" ");
        assertEq (("fi",), mode(x), "mode: words");
        x = range(10);
        foreach int i in (range(10))
            assertEq ((i,), mode (x + i), "mode: discrete data #" + i);
        x = (1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 6, 6, 6, 7, 8, 9, 9);
        assertEq ((2,6), mode(x), "mode: bimodal data");
        x = range(666);
        assertEq (x.size(), mode(x).size(), "mode: unique data");
        code kod = sub () { call_function_args ('mode', argv); };
        assertThrows ("VALUE-ERROR", kod, ((),), "mode: no data");
    }

    test_sum() {
        list x;
        # generic function
        assertEq (50005000, sum (range (10000)), "sum: integers");
        assertEq (0.0, sum (listmul ((1.0, 1e100, 1.0, -1e100), 10000)), "sum: floats"); # NOTE: exploits lack of precision of 64-bit float
        assertEq (20000n, sum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "sum: numbers");
        # generic high precision function
        assertEq (50005000, psum (range (10000)), "psum: integers");
        assertEq (20000.0, psum (listmul ((1.0, 1e100, 1.0, -1e100), 10000)), "psum: floats");
        assertEq (20000n, psum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "psum: numbers");
        # specialised functions
        assertEq (50005000, isum (range (10000)), "isum");
        assertEq (20000.0, fsum (listmul ((1, 1e100, 1, -1e100), 10000)), "fsum");
        assertEq (20000n, nsum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "nsum");
        # start != 0
        x = range(10);
        assertEq (56, sum (x, 1), "sum: start != 0");
        assertEq (56, isum (x, 1), "isum: start != 0");
        assertEq (56.0, fsum (x, 1), "fsum: start != 0");
        assertEq (56n, nsum (x, 1), "nsum: start != 0");
        assertEq (56, psum (x, 1), "psum: start != 0");
        # empty list
        x = ();
        assertEq (0, sum (x), "sum: empty list");
        assertEq (0, isum (x), "isum: empty list");
        assertEq (0.0, fsum (x), "fsum: empty list");
        assertEq (0n, nsum (x), "nsum: empty list");
        assertEq (0, psum (x), "psum: empty list");
    }
}
