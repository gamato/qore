#!/usr/bin/env qore

%requires ../../../../qlib/Math.qm
%requires ../../../../qlib/QUnit.qm

%new-style
%require-types
%enable-all-warnings

%exec-class MathTest

#! Returns a new list as 'num' times concatenated 'arg' list.
list sub listmul (softlist arg, softint num) {
    list r = ();
    while (num > 0) {
        r += arg;
        --num;
    }
    return r;
}


public class MathTest inherits QUnit::Test {
    constructor() : Test ("MathTest", "1.0") {
        addTestCase ("Test listmul helper function", \test_listmul());
        addTestCase ("Test factorial function", \test_factorial());
        addTestCase ("Test gamma function", \test_gamma());
        addTestCase ("Test log function", \test_log());
        addTestCase ("Test mean function", \test_mean());
        addTestCase ("Test median functions", \test_median());
        addTestCase ("Test sum functions", \test_sum());
        set_return_value(main());
    }

    test_listmul() {
        assertEq (list(), listmul ((), 2), "listmul: empty list");
        assertEq (list(), listmul ((1,2), 0), "listmul: num=0");
        assertEq ((1,2), listmul ((1,2), 1), "listmul: num=1");
        assertEq ((1,2,1,2,1,2), listmul ((1,2), 3), "listmul: num>1");
    }

    test_factorial() {
        assertEq (1n, factorial(0), "factorial(0)");
        number total = 1;
        for (int i=1; i<=100; ++i) {
            total *= i;
            assertEq (total, factorial(i), sprintf ("factorial(%d)", i));
        }
        code kod = sub () { call_function_args ('factorial', argv); };
        assertThrows ("VALUE-ERROR", kod, -1, "factorial(-1)");
        assertThrows ("VALUE-ERROR", kod, -1.0, "factorial(-1.0)");
        assertThrows ("VALUE-ERROR", kod, -pow(10, 100), "factorial(-10^100)");
        assertThrows ("VALUE-ERROR", kod, -1e100, "factorial(-1e100)");
        assertThrows ("VALUE-ERROR", kod, M_PI, "factorial(pi)");
    }

    test_gamma() {
        list r = (
                2.67893853, 1.35411794, 1.00000000, 0.89297951, 0.90274529,
                1.00000000, 1.19063935, 1.50457549, 2.00000000, 2.77815848,
                );
        for (float x=1.0; x <= 10.0; x+=1.0)
            assertFloatEq (r[x-1], gamma (x/3.0), 0.00000001, sprintf ("gamma #%d", x));
    }

    test_log() {
        float eps = 0.0000000001;
        assertFloatEq (-1, log (1/M_E), eps, 'log(1/e)');
        assertFloatEq (0, log (1.0), eps, 'log(1)');
        assertFloatEq (1, log (M_E), eps, 'log(e)');
        assertFloatEq (5, log (32.0, 2), eps, 'log(32, 2)');
        assertFloatEq (40, log (pow(10.0, 40), 10), eps, 'log(10^40, 10)');
        assertFloatEq (2, log (pow(10.0, 40), pow(10.0, 20)), eps, 'log(10^40, 10^20)');
        assertNumberEq (2302.5850929940457, log (pow(10n, 1000)), eps, 'log(10^1000)');
        assertTrue (log(-1.5).nanp(), 'log(-1.5)');
        assertTrue (log(-pow(10.0, 1000)).nanp(), 'log(-(10^1000))');
        assertTrue (log(-@Inf@).nanp(), 'log(-@INF@)');
        assertTrue (log(@Inf@).infp(), 'log(+@INF@)');
        assertTrue (log(@NaN@).nanp(), 'log(@NAN@)');
    }

    test_mean() {
        list x;
        # Test mean with ints
        x = (0, 1, 2, 3, 3, 3, 4, 5, 5, 6, 7, 7, 7, 7, 8, 9);
        assertEq (4.8125, mean(x), "mean: integers");
        # Test mean with floats
        x = (17.25, 19.75, 20.0, 21.5, 21.75, 23.25, 25.125, 27.5);
        assertEq (22.015625, mean(x), "mean: floats");
        # Test mean with numbers
        x = (1.634n, 2.517n, 3.912n, 4.072n, 5.813n);
        assertNumberEq (3.5896n, mean(x), 1e-10, "mean: numbers");
        # Test mean with empty list
        code kod = sub () { call_function_args ('mean', argv); };
        assertThrows ("VALUE-ERROR", kod, ((),), "mean: empty list");
        # Mean of (a,b,c...z) should be same as for (a,a,b,b,c,c...z,z)
        x = range(1000);
        assertEq (mean(x), mean (listmul (x,2)), "mean: doubled list");
        # Test adding a large constant to every data point
        float c = 1e9;
        x = (3.4, 4.5, 4.9, 6.7, 6.8, 7.2, 8.0, 8.1, 9.4);
        float exp = mean(x) + c;
        assertTrue (exp != c);
        assertEq (exp, mean (map $1+c, x), "mean: list + large constant");
        # Try to exploit lack of precision of 64-bit float
        x = (1e100, 1, 3, -1e100);
        assertEq (1.0, mean(x), "mean: full precision");
    }

    test_median() {
        list x;
        # Test median with an even number of int data points
        x = (1, 2, 3, 4, 5, 6);
        assertEq (0, x.size() % 2);
        assertEq (3.5, median(x), "median: even count");
        # Test median with an odd number of int data points
        x = (1, 2, 3, 4, 5, 6, 7);
        assertEq (1, x.size() % 2);
        assertEq (4, median(x), "median: odd count");
    }

    test_sum() {
        list x;
        # generic function
        assertEq (50005000, sum (range (10000)), "sum: integers");
        assertEq (0.0, sum (listmul ((1.0, 1e100, 1.0, -1e100), 10000)), "sum: floats"); # NOTE: exploits lack of precision of 64-bit float
        assertEq (20000n, sum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "sum: numbers");
        # generic high precision function
        assertEq (50005000, psum (range (10000)), "psum: integers");
        assertEq (20000.0, psum (listmul ((1.0, 1e100, 1.0, -1e100), 10000)), "psum: floats");
        assertEq (20000n, psum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "psum: numbers");
        # specialised functions
        assertEq (50005000, isum (range (10000)), "isum");
        assertEq (20000.0, fsum (listmul ((1, 1e100, 1, -1e100), 10000)), "fsum");
        assertEq (20000n, nsum (listmul ((1n, 1e100n, 1n, -1e100n), 10000)), "nsum");
        # start != 0
        x = range(10);
        assertEq (56, sum (x, 1), "sum: start != 0");
        assertEq (56, isum (x, 1), "isum: start != 0");
        assertEq (56.0, fsum (x, 1), "fsum: start != 0");
        assertEq (56n, nsum (x, 1), "nsum: start != 0");
        assertEq (56, psum (x, 1), "psum: start != 0");
        # empty list
        x = ();
        assertEq (0, sum (x), "sum: empty list");
        assertEq (0, isum (x), "isum: empty list");
        assertEq (0.0, fsum (x), "fsum: empty list");
        assertEq (0n, nsum (x), "nsum: empty list");
        assertEq (0, psum (x), "psum: empty list");
    }
}
